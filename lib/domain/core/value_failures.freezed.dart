// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'value_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ValueFailureTearOff {
  const _$ValueFailureTearOff();

  VFInvalidEmail<T> invalidEmailAdress<T>({required T failedValue}) {
    return VFInvalidEmail<T>(
      failedValue: failedValue,
    );
  }

  VFInvalidName<T> invalidName<T>({required T failedValue}) {
    return VFInvalidName<T>(
      failedValue: failedValue,
    );
  }

  VFInvalidPhone<T> invalidPhone<T>({required T failedValue}) {
    return VFInvalidPhone<T>(
      failedValue: failedValue,
    );
  }

  VFInvalidOTP<T> invalidOTP<T>({required T failedValue}) {
    return VFInvalidOTP<T>(
      failedValue: failedValue,
    );
  }

  VFInvalidDescription<T> invalidDescription<T>({required T failedValue}) {
    return VFInvalidDescription<T>(
      failedValue: failedValue,
    );
  }

  VFInvalidID<T> invalidID<T>({required T failedValue}) {
    return VFInvalidID<T>(
      failedValue: failedValue,
    );
  }

  VFInValidPrice<T> inValidPrice<T>({required T failedValue}) {
    return VFInValidPrice<T>(
      failedValue: failedValue,
    );
  }

  VFInValidPercentage<T> inValidPercentage<T>({required T failedValue}) {
    return VFInValidPercentage<T>(
      failedValue: failedValue,
    );
  }

  VFInValidQuantity<T> inValidQuantity<T>({required T failedValue}) {
    return VFInValidQuantity<T>(
      failedValue: failedValue,
    );
  }

  VFInValidStock<T> inValidStock<T>({required T failedValue}) {
    return VFInValidStock<T>(
      failedValue: failedValue,
    );
  }

  VFShortPassword<T> shortPassword<T>({required T failedValue}) {
    return VFShortPassword<T>(
      failedValue: failedValue,
    );
  }
}

/// @nodoc
const $ValueFailure = _$ValueFailureTearOff();

/// @nodoc
mixin _$ValueFailure<T> {
  T get failedValue => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmailAdress,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidOTP,
    required TResult Function(T failedValue) invalidDescription,
    required TResult Function(T failedValue) invalidID,
    required TResult Function(T failedValue) inValidPrice,
    required TResult Function(T failedValue) inValidPercentage,
    required TResult Function(T failedValue) inValidQuantity,
    required TResult Function(T failedValue) inValidStock,
    required TResult Function(T failedValue) shortPassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmailAdress,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidOTP,
    TResult Function(T failedValue)? invalidDescription,
    TResult Function(T failedValue)? invalidID,
    TResult Function(T failedValue)? inValidPrice,
    TResult Function(T failedValue)? inValidPercentage,
    TResult Function(T failedValue)? inValidQuantity,
    TResult Function(T failedValue)? inValidStock,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VFInvalidEmail<T> value) invalidEmailAdress,
    required TResult Function(VFInvalidName<T> value) invalidName,
    required TResult Function(VFInvalidPhone<T> value) invalidPhone,
    required TResult Function(VFInvalidOTP<T> value) invalidOTP,
    required TResult Function(VFInvalidDescription<T> value) invalidDescription,
    required TResult Function(VFInvalidID<T> value) invalidID,
    required TResult Function(VFInValidPrice<T> value) inValidPrice,
    required TResult Function(VFInValidPercentage<T> value) inValidPercentage,
    required TResult Function(VFInValidQuantity<T> value) inValidQuantity,
    required TResult Function(VFInValidStock<T> value) inValidStock,
    required TResult Function(VFShortPassword<T> value) shortPassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VFInvalidEmail<T> value)? invalidEmailAdress,
    TResult Function(VFInvalidName<T> value)? invalidName,
    TResult Function(VFInvalidPhone<T> value)? invalidPhone,
    TResult Function(VFInvalidOTP<T> value)? invalidOTP,
    TResult Function(VFInvalidDescription<T> value)? invalidDescription,
    TResult Function(VFInvalidID<T> value)? invalidID,
    TResult Function(VFInValidPrice<T> value)? inValidPrice,
    TResult Function(VFInValidPercentage<T> value)? inValidPercentage,
    TResult Function(VFInValidQuantity<T> value)? inValidQuantity,
    TResult Function(VFInValidStock<T> value)? inValidStock,
    TResult Function(VFShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ValueFailureCopyWith<T, ValueFailure<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  final ValueFailure<T> _value;
  // ignore: unused_field
  final $Res Function(ValueFailure<T>) _then;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_value.copyWith(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc
abstract class $VFInvalidEmailCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInvalidEmailCopyWith(
          VFInvalidEmail<T> value, $Res Function(VFInvalidEmail<T>) then) =
      _$VFInvalidEmailCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInvalidEmailCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInvalidEmailCopyWith<T, $Res> {
  _$VFInvalidEmailCopyWithImpl(
      VFInvalidEmail<T> _value, $Res Function(VFInvalidEmail<T>) _then)
      : super(_value, (v) => _then(v as VFInvalidEmail<T>));

  @override
  VFInvalidEmail<T> get _value => super._value as VFInvalidEmail<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(VFInvalidEmail<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$VFInvalidEmail<T>
    with DiagnosticableTreeMixin
    implements VFInvalidEmail<T> {
  const _$VFInvalidEmail({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidEmailAdress(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidEmailAdress'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInvalidEmail<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInvalidEmailCopyWith<T, VFInvalidEmail<T>> get copyWith =>
      _$VFInvalidEmailCopyWithImpl<T, VFInvalidEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmailAdress,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidOTP,
    required TResult Function(T failedValue) invalidDescription,
    required TResult Function(T failedValue) invalidID,
    required TResult Function(T failedValue) inValidPrice,
    required TResult Function(T failedValue) inValidPercentage,
    required TResult Function(T failedValue) inValidQuantity,
    required TResult Function(T failedValue) inValidStock,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return invalidEmailAdress(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmailAdress,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidOTP,
    TResult Function(T failedValue)? invalidDescription,
    TResult Function(T failedValue)? invalidID,
    TResult Function(T failedValue)? inValidPrice,
    TResult Function(T failedValue)? inValidPercentage,
    TResult Function(T failedValue)? inValidQuantity,
    TResult Function(T failedValue)? inValidStock,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidEmailAdress != null) {
      return invalidEmailAdress(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VFInvalidEmail<T> value) invalidEmailAdress,
    required TResult Function(VFInvalidName<T> value) invalidName,
    required TResult Function(VFInvalidPhone<T> value) invalidPhone,
    required TResult Function(VFInvalidOTP<T> value) invalidOTP,
    required TResult Function(VFInvalidDescription<T> value) invalidDescription,
    required TResult Function(VFInvalidID<T> value) invalidID,
    required TResult Function(VFInValidPrice<T> value) inValidPrice,
    required TResult Function(VFInValidPercentage<T> value) inValidPercentage,
    required TResult Function(VFInValidQuantity<T> value) inValidQuantity,
    required TResult Function(VFInValidStock<T> value) inValidStock,
    required TResult Function(VFShortPassword<T> value) shortPassword,
  }) {
    return invalidEmailAdress(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VFInvalidEmail<T> value)? invalidEmailAdress,
    TResult Function(VFInvalidName<T> value)? invalidName,
    TResult Function(VFInvalidPhone<T> value)? invalidPhone,
    TResult Function(VFInvalidOTP<T> value)? invalidOTP,
    TResult Function(VFInvalidDescription<T> value)? invalidDescription,
    TResult Function(VFInvalidID<T> value)? invalidID,
    TResult Function(VFInValidPrice<T> value)? inValidPrice,
    TResult Function(VFInValidPercentage<T> value)? inValidPercentage,
    TResult Function(VFInValidQuantity<T> value)? inValidQuantity,
    TResult Function(VFInValidStock<T> value)? inValidStock,
    TResult Function(VFShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidEmailAdress != null) {
      return invalidEmailAdress(this);
    }
    return orElse();
  }
}

abstract class VFInvalidEmail<T> implements ValueFailure<T> {
  const factory VFInvalidEmail({required T failedValue}) = _$VFInvalidEmail<T>;

  @override
  T get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $VFInvalidEmailCopyWith<T, VFInvalidEmail<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VFInvalidNameCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInvalidNameCopyWith(
          VFInvalidName<T> value, $Res Function(VFInvalidName<T>) then) =
      _$VFInvalidNameCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInvalidNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInvalidNameCopyWith<T, $Res> {
  _$VFInvalidNameCopyWithImpl(
      VFInvalidName<T> _value, $Res Function(VFInvalidName<T>) _then)
      : super(_value, (v) => _then(v as VFInvalidName<T>));

  @override
  VFInvalidName<T> get _value => super._value as VFInvalidName<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(VFInvalidName<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$VFInvalidName<T>
    with DiagnosticableTreeMixin
    implements VFInvalidName<T> {
  const _$VFInvalidName({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidName(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidName'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInvalidName<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInvalidNameCopyWith<T, VFInvalidName<T>> get copyWith =>
      _$VFInvalidNameCopyWithImpl<T, VFInvalidName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmailAdress,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidOTP,
    required TResult Function(T failedValue) invalidDescription,
    required TResult Function(T failedValue) invalidID,
    required TResult Function(T failedValue) inValidPrice,
    required TResult Function(T failedValue) inValidPercentage,
    required TResult Function(T failedValue) inValidQuantity,
    required TResult Function(T failedValue) inValidStock,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return invalidName(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmailAdress,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidOTP,
    TResult Function(T failedValue)? invalidDescription,
    TResult Function(T failedValue)? invalidID,
    TResult Function(T failedValue)? inValidPrice,
    TResult Function(T failedValue)? inValidPercentage,
    TResult Function(T failedValue)? inValidQuantity,
    TResult Function(T failedValue)? inValidStock,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidName != null) {
      return invalidName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VFInvalidEmail<T> value) invalidEmailAdress,
    required TResult Function(VFInvalidName<T> value) invalidName,
    required TResult Function(VFInvalidPhone<T> value) invalidPhone,
    required TResult Function(VFInvalidOTP<T> value) invalidOTP,
    required TResult Function(VFInvalidDescription<T> value) invalidDescription,
    required TResult Function(VFInvalidID<T> value) invalidID,
    required TResult Function(VFInValidPrice<T> value) inValidPrice,
    required TResult Function(VFInValidPercentage<T> value) inValidPercentage,
    required TResult Function(VFInValidQuantity<T> value) inValidQuantity,
    required TResult Function(VFInValidStock<T> value) inValidStock,
    required TResult Function(VFShortPassword<T> value) shortPassword,
  }) {
    return invalidName(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VFInvalidEmail<T> value)? invalidEmailAdress,
    TResult Function(VFInvalidName<T> value)? invalidName,
    TResult Function(VFInvalidPhone<T> value)? invalidPhone,
    TResult Function(VFInvalidOTP<T> value)? invalidOTP,
    TResult Function(VFInvalidDescription<T> value)? invalidDescription,
    TResult Function(VFInvalidID<T> value)? invalidID,
    TResult Function(VFInValidPrice<T> value)? inValidPrice,
    TResult Function(VFInValidPercentage<T> value)? inValidPercentage,
    TResult Function(VFInValidQuantity<T> value)? inValidQuantity,
    TResult Function(VFInValidStock<T> value)? inValidStock,
    TResult Function(VFShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidName != null) {
      return invalidName(this);
    }
    return orElse();
  }
}

abstract class VFInvalidName<T> implements ValueFailure<T> {
  const factory VFInvalidName({required T failedValue}) = _$VFInvalidName<T>;

  @override
  T get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $VFInvalidNameCopyWith<T, VFInvalidName<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VFInvalidPhoneCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInvalidPhoneCopyWith(
          VFInvalidPhone<T> value, $Res Function(VFInvalidPhone<T>) then) =
      _$VFInvalidPhoneCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInvalidPhoneCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInvalidPhoneCopyWith<T, $Res> {
  _$VFInvalidPhoneCopyWithImpl(
      VFInvalidPhone<T> _value, $Res Function(VFInvalidPhone<T>) _then)
      : super(_value, (v) => _then(v as VFInvalidPhone<T>));

  @override
  VFInvalidPhone<T> get _value => super._value as VFInvalidPhone<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(VFInvalidPhone<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$VFInvalidPhone<T>
    with DiagnosticableTreeMixin
    implements VFInvalidPhone<T> {
  const _$VFInvalidPhone({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidPhone(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidPhone'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInvalidPhone<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInvalidPhoneCopyWith<T, VFInvalidPhone<T>> get copyWith =>
      _$VFInvalidPhoneCopyWithImpl<T, VFInvalidPhone<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmailAdress,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidOTP,
    required TResult Function(T failedValue) invalidDescription,
    required TResult Function(T failedValue) invalidID,
    required TResult Function(T failedValue) inValidPrice,
    required TResult Function(T failedValue) inValidPercentage,
    required TResult Function(T failedValue) inValidQuantity,
    required TResult Function(T failedValue) inValidStock,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return invalidPhone(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmailAdress,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidOTP,
    TResult Function(T failedValue)? invalidDescription,
    TResult Function(T failedValue)? invalidID,
    TResult Function(T failedValue)? inValidPrice,
    TResult Function(T failedValue)? inValidPercentage,
    TResult Function(T failedValue)? inValidQuantity,
    TResult Function(T failedValue)? inValidStock,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidPhone != null) {
      return invalidPhone(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VFInvalidEmail<T> value) invalidEmailAdress,
    required TResult Function(VFInvalidName<T> value) invalidName,
    required TResult Function(VFInvalidPhone<T> value) invalidPhone,
    required TResult Function(VFInvalidOTP<T> value) invalidOTP,
    required TResult Function(VFInvalidDescription<T> value) invalidDescription,
    required TResult Function(VFInvalidID<T> value) invalidID,
    required TResult Function(VFInValidPrice<T> value) inValidPrice,
    required TResult Function(VFInValidPercentage<T> value) inValidPercentage,
    required TResult Function(VFInValidQuantity<T> value) inValidQuantity,
    required TResult Function(VFInValidStock<T> value) inValidStock,
    required TResult Function(VFShortPassword<T> value) shortPassword,
  }) {
    return invalidPhone(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VFInvalidEmail<T> value)? invalidEmailAdress,
    TResult Function(VFInvalidName<T> value)? invalidName,
    TResult Function(VFInvalidPhone<T> value)? invalidPhone,
    TResult Function(VFInvalidOTP<T> value)? invalidOTP,
    TResult Function(VFInvalidDescription<T> value)? invalidDescription,
    TResult Function(VFInvalidID<T> value)? invalidID,
    TResult Function(VFInValidPrice<T> value)? inValidPrice,
    TResult Function(VFInValidPercentage<T> value)? inValidPercentage,
    TResult Function(VFInValidQuantity<T> value)? inValidQuantity,
    TResult Function(VFInValidStock<T> value)? inValidStock,
    TResult Function(VFShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidPhone != null) {
      return invalidPhone(this);
    }
    return orElse();
  }
}

abstract class VFInvalidPhone<T> implements ValueFailure<T> {
  const factory VFInvalidPhone({required T failedValue}) = _$VFInvalidPhone<T>;

  @override
  T get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $VFInvalidPhoneCopyWith<T, VFInvalidPhone<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VFInvalidOTPCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInvalidOTPCopyWith(
          VFInvalidOTP<T> value, $Res Function(VFInvalidOTP<T>) then) =
      _$VFInvalidOTPCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInvalidOTPCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInvalidOTPCopyWith<T, $Res> {
  _$VFInvalidOTPCopyWithImpl(
      VFInvalidOTP<T> _value, $Res Function(VFInvalidOTP<T>) _then)
      : super(_value, (v) => _then(v as VFInvalidOTP<T>));

  @override
  VFInvalidOTP<T> get _value => super._value as VFInvalidOTP<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(VFInvalidOTP<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$VFInvalidOTP<T>
    with DiagnosticableTreeMixin
    implements VFInvalidOTP<T> {
  const _$VFInvalidOTP({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidOTP(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidOTP'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInvalidOTP<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInvalidOTPCopyWith<T, VFInvalidOTP<T>> get copyWith =>
      _$VFInvalidOTPCopyWithImpl<T, VFInvalidOTP<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmailAdress,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidOTP,
    required TResult Function(T failedValue) invalidDescription,
    required TResult Function(T failedValue) invalidID,
    required TResult Function(T failedValue) inValidPrice,
    required TResult Function(T failedValue) inValidPercentage,
    required TResult Function(T failedValue) inValidQuantity,
    required TResult Function(T failedValue) inValidStock,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return invalidOTP(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmailAdress,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidOTP,
    TResult Function(T failedValue)? invalidDescription,
    TResult Function(T failedValue)? invalidID,
    TResult Function(T failedValue)? inValidPrice,
    TResult Function(T failedValue)? inValidPercentage,
    TResult Function(T failedValue)? inValidQuantity,
    TResult Function(T failedValue)? inValidStock,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidOTP != null) {
      return invalidOTP(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VFInvalidEmail<T> value) invalidEmailAdress,
    required TResult Function(VFInvalidName<T> value) invalidName,
    required TResult Function(VFInvalidPhone<T> value) invalidPhone,
    required TResult Function(VFInvalidOTP<T> value) invalidOTP,
    required TResult Function(VFInvalidDescription<T> value) invalidDescription,
    required TResult Function(VFInvalidID<T> value) invalidID,
    required TResult Function(VFInValidPrice<T> value) inValidPrice,
    required TResult Function(VFInValidPercentage<T> value) inValidPercentage,
    required TResult Function(VFInValidQuantity<T> value) inValidQuantity,
    required TResult Function(VFInValidStock<T> value) inValidStock,
    required TResult Function(VFShortPassword<T> value) shortPassword,
  }) {
    return invalidOTP(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VFInvalidEmail<T> value)? invalidEmailAdress,
    TResult Function(VFInvalidName<T> value)? invalidName,
    TResult Function(VFInvalidPhone<T> value)? invalidPhone,
    TResult Function(VFInvalidOTP<T> value)? invalidOTP,
    TResult Function(VFInvalidDescription<T> value)? invalidDescription,
    TResult Function(VFInvalidID<T> value)? invalidID,
    TResult Function(VFInValidPrice<T> value)? inValidPrice,
    TResult Function(VFInValidPercentage<T> value)? inValidPercentage,
    TResult Function(VFInValidQuantity<T> value)? inValidQuantity,
    TResult Function(VFInValidStock<T> value)? inValidStock,
    TResult Function(VFShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidOTP != null) {
      return invalidOTP(this);
    }
    return orElse();
  }
}

abstract class VFInvalidOTP<T> implements ValueFailure<T> {
  const factory VFInvalidOTP({required T failedValue}) = _$VFInvalidOTP<T>;

  @override
  T get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $VFInvalidOTPCopyWith<T, VFInvalidOTP<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VFInvalidDescriptionCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInvalidDescriptionCopyWith(VFInvalidDescription<T> value,
          $Res Function(VFInvalidDescription<T>) then) =
      _$VFInvalidDescriptionCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInvalidDescriptionCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInvalidDescriptionCopyWith<T, $Res> {
  _$VFInvalidDescriptionCopyWithImpl(VFInvalidDescription<T> _value,
      $Res Function(VFInvalidDescription<T>) _then)
      : super(_value, (v) => _then(v as VFInvalidDescription<T>));

  @override
  VFInvalidDescription<T> get _value => super._value as VFInvalidDescription<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(VFInvalidDescription<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$VFInvalidDescription<T>
    with DiagnosticableTreeMixin
    implements VFInvalidDescription<T> {
  const _$VFInvalidDescription({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidDescription(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidDescription'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInvalidDescription<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInvalidDescriptionCopyWith<T, VFInvalidDescription<T>> get copyWith =>
      _$VFInvalidDescriptionCopyWithImpl<T, VFInvalidDescription<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmailAdress,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidOTP,
    required TResult Function(T failedValue) invalidDescription,
    required TResult Function(T failedValue) invalidID,
    required TResult Function(T failedValue) inValidPrice,
    required TResult Function(T failedValue) inValidPercentage,
    required TResult Function(T failedValue) inValidQuantity,
    required TResult Function(T failedValue) inValidStock,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return invalidDescription(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmailAdress,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidOTP,
    TResult Function(T failedValue)? invalidDescription,
    TResult Function(T failedValue)? invalidID,
    TResult Function(T failedValue)? inValidPrice,
    TResult Function(T failedValue)? inValidPercentage,
    TResult Function(T failedValue)? inValidQuantity,
    TResult Function(T failedValue)? inValidStock,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidDescription != null) {
      return invalidDescription(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VFInvalidEmail<T> value) invalidEmailAdress,
    required TResult Function(VFInvalidName<T> value) invalidName,
    required TResult Function(VFInvalidPhone<T> value) invalidPhone,
    required TResult Function(VFInvalidOTP<T> value) invalidOTP,
    required TResult Function(VFInvalidDescription<T> value) invalidDescription,
    required TResult Function(VFInvalidID<T> value) invalidID,
    required TResult Function(VFInValidPrice<T> value) inValidPrice,
    required TResult Function(VFInValidPercentage<T> value) inValidPercentage,
    required TResult Function(VFInValidQuantity<T> value) inValidQuantity,
    required TResult Function(VFInValidStock<T> value) inValidStock,
    required TResult Function(VFShortPassword<T> value) shortPassword,
  }) {
    return invalidDescription(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VFInvalidEmail<T> value)? invalidEmailAdress,
    TResult Function(VFInvalidName<T> value)? invalidName,
    TResult Function(VFInvalidPhone<T> value)? invalidPhone,
    TResult Function(VFInvalidOTP<T> value)? invalidOTP,
    TResult Function(VFInvalidDescription<T> value)? invalidDescription,
    TResult Function(VFInvalidID<T> value)? invalidID,
    TResult Function(VFInValidPrice<T> value)? inValidPrice,
    TResult Function(VFInValidPercentage<T> value)? inValidPercentage,
    TResult Function(VFInValidQuantity<T> value)? inValidQuantity,
    TResult Function(VFInValidStock<T> value)? inValidStock,
    TResult Function(VFShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidDescription != null) {
      return invalidDescription(this);
    }
    return orElse();
  }
}

abstract class VFInvalidDescription<T> implements ValueFailure<T> {
  const factory VFInvalidDescription({required T failedValue}) =
      _$VFInvalidDescription<T>;

  @override
  T get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $VFInvalidDescriptionCopyWith<T, VFInvalidDescription<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VFInvalidIDCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInvalidIDCopyWith(
          VFInvalidID<T> value, $Res Function(VFInvalidID<T>) then) =
      _$VFInvalidIDCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInvalidIDCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInvalidIDCopyWith<T, $Res> {
  _$VFInvalidIDCopyWithImpl(
      VFInvalidID<T> _value, $Res Function(VFInvalidID<T>) _then)
      : super(_value, (v) => _then(v as VFInvalidID<T>));

  @override
  VFInvalidID<T> get _value => super._value as VFInvalidID<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(VFInvalidID<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$VFInvalidID<T> with DiagnosticableTreeMixin implements VFInvalidID<T> {
  const _$VFInvalidID({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.invalidID(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.invalidID'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInvalidID<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInvalidIDCopyWith<T, VFInvalidID<T>> get copyWith =>
      _$VFInvalidIDCopyWithImpl<T, VFInvalidID<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmailAdress,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidOTP,
    required TResult Function(T failedValue) invalidDescription,
    required TResult Function(T failedValue) invalidID,
    required TResult Function(T failedValue) inValidPrice,
    required TResult Function(T failedValue) inValidPercentage,
    required TResult Function(T failedValue) inValidQuantity,
    required TResult Function(T failedValue) inValidStock,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return invalidID(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmailAdress,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidOTP,
    TResult Function(T failedValue)? invalidDescription,
    TResult Function(T failedValue)? invalidID,
    TResult Function(T failedValue)? inValidPrice,
    TResult Function(T failedValue)? inValidPercentage,
    TResult Function(T failedValue)? inValidQuantity,
    TResult Function(T failedValue)? inValidStock,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidID != null) {
      return invalidID(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VFInvalidEmail<T> value) invalidEmailAdress,
    required TResult Function(VFInvalidName<T> value) invalidName,
    required TResult Function(VFInvalidPhone<T> value) invalidPhone,
    required TResult Function(VFInvalidOTP<T> value) invalidOTP,
    required TResult Function(VFInvalidDescription<T> value) invalidDescription,
    required TResult Function(VFInvalidID<T> value) invalidID,
    required TResult Function(VFInValidPrice<T> value) inValidPrice,
    required TResult Function(VFInValidPercentage<T> value) inValidPercentage,
    required TResult Function(VFInValidQuantity<T> value) inValidQuantity,
    required TResult Function(VFInValidStock<T> value) inValidStock,
    required TResult Function(VFShortPassword<T> value) shortPassword,
  }) {
    return invalidID(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VFInvalidEmail<T> value)? invalidEmailAdress,
    TResult Function(VFInvalidName<T> value)? invalidName,
    TResult Function(VFInvalidPhone<T> value)? invalidPhone,
    TResult Function(VFInvalidOTP<T> value)? invalidOTP,
    TResult Function(VFInvalidDescription<T> value)? invalidDescription,
    TResult Function(VFInvalidID<T> value)? invalidID,
    TResult Function(VFInValidPrice<T> value)? inValidPrice,
    TResult Function(VFInValidPercentage<T> value)? inValidPercentage,
    TResult Function(VFInValidQuantity<T> value)? inValidQuantity,
    TResult Function(VFInValidStock<T> value)? inValidStock,
    TResult Function(VFShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidID != null) {
      return invalidID(this);
    }
    return orElse();
  }
}

abstract class VFInvalidID<T> implements ValueFailure<T> {
  const factory VFInvalidID({required T failedValue}) = _$VFInvalidID<T>;

  @override
  T get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $VFInvalidIDCopyWith<T, VFInvalidID<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VFInValidPriceCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInValidPriceCopyWith(
          VFInValidPrice<T> value, $Res Function(VFInValidPrice<T>) then) =
      _$VFInValidPriceCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInValidPriceCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInValidPriceCopyWith<T, $Res> {
  _$VFInValidPriceCopyWithImpl(
      VFInValidPrice<T> _value, $Res Function(VFInValidPrice<T>) _then)
      : super(_value, (v) => _then(v as VFInValidPrice<T>));

  @override
  VFInValidPrice<T> get _value => super._value as VFInValidPrice<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(VFInValidPrice<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$VFInValidPrice<T>
    with DiagnosticableTreeMixin
    implements VFInValidPrice<T> {
  const _$VFInValidPrice({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.inValidPrice(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.inValidPrice'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInValidPrice<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInValidPriceCopyWith<T, VFInValidPrice<T>> get copyWith =>
      _$VFInValidPriceCopyWithImpl<T, VFInValidPrice<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmailAdress,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidOTP,
    required TResult Function(T failedValue) invalidDescription,
    required TResult Function(T failedValue) invalidID,
    required TResult Function(T failedValue) inValidPrice,
    required TResult Function(T failedValue) inValidPercentage,
    required TResult Function(T failedValue) inValidQuantity,
    required TResult Function(T failedValue) inValidStock,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return inValidPrice(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmailAdress,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidOTP,
    TResult Function(T failedValue)? invalidDescription,
    TResult Function(T failedValue)? invalidID,
    TResult Function(T failedValue)? inValidPrice,
    TResult Function(T failedValue)? inValidPercentage,
    TResult Function(T failedValue)? inValidQuantity,
    TResult Function(T failedValue)? inValidStock,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (inValidPrice != null) {
      return inValidPrice(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VFInvalidEmail<T> value) invalidEmailAdress,
    required TResult Function(VFInvalidName<T> value) invalidName,
    required TResult Function(VFInvalidPhone<T> value) invalidPhone,
    required TResult Function(VFInvalidOTP<T> value) invalidOTP,
    required TResult Function(VFInvalidDescription<T> value) invalidDescription,
    required TResult Function(VFInvalidID<T> value) invalidID,
    required TResult Function(VFInValidPrice<T> value) inValidPrice,
    required TResult Function(VFInValidPercentage<T> value) inValidPercentage,
    required TResult Function(VFInValidQuantity<T> value) inValidQuantity,
    required TResult Function(VFInValidStock<T> value) inValidStock,
    required TResult Function(VFShortPassword<T> value) shortPassword,
  }) {
    return inValidPrice(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VFInvalidEmail<T> value)? invalidEmailAdress,
    TResult Function(VFInvalidName<T> value)? invalidName,
    TResult Function(VFInvalidPhone<T> value)? invalidPhone,
    TResult Function(VFInvalidOTP<T> value)? invalidOTP,
    TResult Function(VFInvalidDescription<T> value)? invalidDescription,
    TResult Function(VFInvalidID<T> value)? invalidID,
    TResult Function(VFInValidPrice<T> value)? inValidPrice,
    TResult Function(VFInValidPercentage<T> value)? inValidPercentage,
    TResult Function(VFInValidQuantity<T> value)? inValidQuantity,
    TResult Function(VFInValidStock<T> value)? inValidStock,
    TResult Function(VFShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (inValidPrice != null) {
      return inValidPrice(this);
    }
    return orElse();
  }
}

abstract class VFInValidPrice<T> implements ValueFailure<T> {
  const factory VFInValidPrice({required T failedValue}) = _$VFInValidPrice<T>;

  @override
  T get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $VFInValidPriceCopyWith<T, VFInValidPrice<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VFInValidPercentageCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInValidPercentageCopyWith(VFInValidPercentage<T> value,
          $Res Function(VFInValidPercentage<T>) then) =
      _$VFInValidPercentageCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInValidPercentageCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInValidPercentageCopyWith<T, $Res> {
  _$VFInValidPercentageCopyWithImpl(VFInValidPercentage<T> _value,
      $Res Function(VFInValidPercentage<T>) _then)
      : super(_value, (v) => _then(v as VFInValidPercentage<T>));

  @override
  VFInValidPercentage<T> get _value => super._value as VFInValidPercentage<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(VFInValidPercentage<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$VFInValidPercentage<T>
    with DiagnosticableTreeMixin
    implements VFInValidPercentage<T> {
  const _$VFInValidPercentage({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.inValidPercentage(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.inValidPercentage'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInValidPercentage<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInValidPercentageCopyWith<T, VFInValidPercentage<T>> get copyWith =>
      _$VFInValidPercentageCopyWithImpl<T, VFInValidPercentage<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmailAdress,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidOTP,
    required TResult Function(T failedValue) invalidDescription,
    required TResult Function(T failedValue) invalidID,
    required TResult Function(T failedValue) inValidPrice,
    required TResult Function(T failedValue) inValidPercentage,
    required TResult Function(T failedValue) inValidQuantity,
    required TResult Function(T failedValue) inValidStock,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return inValidPercentage(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmailAdress,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidOTP,
    TResult Function(T failedValue)? invalidDescription,
    TResult Function(T failedValue)? invalidID,
    TResult Function(T failedValue)? inValidPrice,
    TResult Function(T failedValue)? inValidPercentage,
    TResult Function(T failedValue)? inValidQuantity,
    TResult Function(T failedValue)? inValidStock,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (inValidPercentage != null) {
      return inValidPercentage(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VFInvalidEmail<T> value) invalidEmailAdress,
    required TResult Function(VFInvalidName<T> value) invalidName,
    required TResult Function(VFInvalidPhone<T> value) invalidPhone,
    required TResult Function(VFInvalidOTP<T> value) invalidOTP,
    required TResult Function(VFInvalidDescription<T> value) invalidDescription,
    required TResult Function(VFInvalidID<T> value) invalidID,
    required TResult Function(VFInValidPrice<T> value) inValidPrice,
    required TResult Function(VFInValidPercentage<T> value) inValidPercentage,
    required TResult Function(VFInValidQuantity<T> value) inValidQuantity,
    required TResult Function(VFInValidStock<T> value) inValidStock,
    required TResult Function(VFShortPassword<T> value) shortPassword,
  }) {
    return inValidPercentage(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VFInvalidEmail<T> value)? invalidEmailAdress,
    TResult Function(VFInvalidName<T> value)? invalidName,
    TResult Function(VFInvalidPhone<T> value)? invalidPhone,
    TResult Function(VFInvalidOTP<T> value)? invalidOTP,
    TResult Function(VFInvalidDescription<T> value)? invalidDescription,
    TResult Function(VFInvalidID<T> value)? invalidID,
    TResult Function(VFInValidPrice<T> value)? inValidPrice,
    TResult Function(VFInValidPercentage<T> value)? inValidPercentage,
    TResult Function(VFInValidQuantity<T> value)? inValidQuantity,
    TResult Function(VFInValidStock<T> value)? inValidStock,
    TResult Function(VFShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (inValidPercentage != null) {
      return inValidPercentage(this);
    }
    return orElse();
  }
}

abstract class VFInValidPercentage<T> implements ValueFailure<T> {
  const factory VFInValidPercentage({required T failedValue}) =
      _$VFInValidPercentage<T>;

  @override
  T get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $VFInValidPercentageCopyWith<T, VFInValidPercentage<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VFInValidQuantityCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInValidQuantityCopyWith(VFInValidQuantity<T> value,
          $Res Function(VFInValidQuantity<T>) then) =
      _$VFInValidQuantityCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInValidQuantityCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInValidQuantityCopyWith<T, $Res> {
  _$VFInValidQuantityCopyWithImpl(
      VFInValidQuantity<T> _value, $Res Function(VFInValidQuantity<T>) _then)
      : super(_value, (v) => _then(v as VFInValidQuantity<T>));

  @override
  VFInValidQuantity<T> get _value => super._value as VFInValidQuantity<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(VFInValidQuantity<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$VFInValidQuantity<T>
    with DiagnosticableTreeMixin
    implements VFInValidQuantity<T> {
  const _$VFInValidQuantity({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.inValidQuantity(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.inValidQuantity'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInValidQuantity<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInValidQuantityCopyWith<T, VFInValidQuantity<T>> get copyWith =>
      _$VFInValidQuantityCopyWithImpl<T, VFInValidQuantity<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmailAdress,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidOTP,
    required TResult Function(T failedValue) invalidDescription,
    required TResult Function(T failedValue) invalidID,
    required TResult Function(T failedValue) inValidPrice,
    required TResult Function(T failedValue) inValidPercentage,
    required TResult Function(T failedValue) inValidQuantity,
    required TResult Function(T failedValue) inValidStock,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return inValidQuantity(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmailAdress,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidOTP,
    TResult Function(T failedValue)? invalidDescription,
    TResult Function(T failedValue)? invalidID,
    TResult Function(T failedValue)? inValidPrice,
    TResult Function(T failedValue)? inValidPercentage,
    TResult Function(T failedValue)? inValidQuantity,
    TResult Function(T failedValue)? inValidStock,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (inValidQuantity != null) {
      return inValidQuantity(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VFInvalidEmail<T> value) invalidEmailAdress,
    required TResult Function(VFInvalidName<T> value) invalidName,
    required TResult Function(VFInvalidPhone<T> value) invalidPhone,
    required TResult Function(VFInvalidOTP<T> value) invalidOTP,
    required TResult Function(VFInvalidDescription<T> value) invalidDescription,
    required TResult Function(VFInvalidID<T> value) invalidID,
    required TResult Function(VFInValidPrice<T> value) inValidPrice,
    required TResult Function(VFInValidPercentage<T> value) inValidPercentage,
    required TResult Function(VFInValidQuantity<T> value) inValidQuantity,
    required TResult Function(VFInValidStock<T> value) inValidStock,
    required TResult Function(VFShortPassword<T> value) shortPassword,
  }) {
    return inValidQuantity(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VFInvalidEmail<T> value)? invalidEmailAdress,
    TResult Function(VFInvalidName<T> value)? invalidName,
    TResult Function(VFInvalidPhone<T> value)? invalidPhone,
    TResult Function(VFInvalidOTP<T> value)? invalidOTP,
    TResult Function(VFInvalidDescription<T> value)? invalidDescription,
    TResult Function(VFInvalidID<T> value)? invalidID,
    TResult Function(VFInValidPrice<T> value)? inValidPrice,
    TResult Function(VFInValidPercentage<T> value)? inValidPercentage,
    TResult Function(VFInValidQuantity<T> value)? inValidQuantity,
    TResult Function(VFInValidStock<T> value)? inValidStock,
    TResult Function(VFShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (inValidQuantity != null) {
      return inValidQuantity(this);
    }
    return orElse();
  }
}

abstract class VFInValidQuantity<T> implements ValueFailure<T> {
  const factory VFInValidQuantity({required T failedValue}) =
      _$VFInValidQuantity<T>;

  @override
  T get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $VFInValidQuantityCopyWith<T, VFInValidQuantity<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VFInValidStockCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFInValidStockCopyWith(
          VFInValidStock<T> value, $Res Function(VFInValidStock<T>) then) =
      _$VFInValidStockCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFInValidStockCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFInValidStockCopyWith<T, $Res> {
  _$VFInValidStockCopyWithImpl(
      VFInValidStock<T> _value, $Res Function(VFInValidStock<T>) _then)
      : super(_value, (v) => _then(v as VFInValidStock<T>));

  @override
  VFInValidStock<T> get _value => super._value as VFInValidStock<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(VFInValidStock<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$VFInValidStock<T>
    with DiagnosticableTreeMixin
    implements VFInValidStock<T> {
  const _$VFInValidStock({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.inValidStock(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.inValidStock'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFInValidStock<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFInValidStockCopyWith<T, VFInValidStock<T>> get copyWith =>
      _$VFInValidStockCopyWithImpl<T, VFInValidStock<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmailAdress,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidOTP,
    required TResult Function(T failedValue) invalidDescription,
    required TResult Function(T failedValue) invalidID,
    required TResult Function(T failedValue) inValidPrice,
    required TResult Function(T failedValue) inValidPercentage,
    required TResult Function(T failedValue) inValidQuantity,
    required TResult Function(T failedValue) inValidStock,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return inValidStock(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmailAdress,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidOTP,
    TResult Function(T failedValue)? invalidDescription,
    TResult Function(T failedValue)? invalidID,
    TResult Function(T failedValue)? inValidPrice,
    TResult Function(T failedValue)? inValidPercentage,
    TResult Function(T failedValue)? inValidQuantity,
    TResult Function(T failedValue)? inValidStock,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (inValidStock != null) {
      return inValidStock(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VFInvalidEmail<T> value) invalidEmailAdress,
    required TResult Function(VFInvalidName<T> value) invalidName,
    required TResult Function(VFInvalidPhone<T> value) invalidPhone,
    required TResult Function(VFInvalidOTP<T> value) invalidOTP,
    required TResult Function(VFInvalidDescription<T> value) invalidDescription,
    required TResult Function(VFInvalidID<T> value) invalidID,
    required TResult Function(VFInValidPrice<T> value) inValidPrice,
    required TResult Function(VFInValidPercentage<T> value) inValidPercentage,
    required TResult Function(VFInValidQuantity<T> value) inValidQuantity,
    required TResult Function(VFInValidStock<T> value) inValidStock,
    required TResult Function(VFShortPassword<T> value) shortPassword,
  }) {
    return inValidStock(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VFInvalidEmail<T> value)? invalidEmailAdress,
    TResult Function(VFInvalidName<T> value)? invalidName,
    TResult Function(VFInvalidPhone<T> value)? invalidPhone,
    TResult Function(VFInvalidOTP<T> value)? invalidOTP,
    TResult Function(VFInvalidDescription<T> value)? invalidDescription,
    TResult Function(VFInvalidID<T> value)? invalidID,
    TResult Function(VFInValidPrice<T> value)? inValidPrice,
    TResult Function(VFInValidPercentage<T> value)? inValidPercentage,
    TResult Function(VFInValidQuantity<T> value)? inValidQuantity,
    TResult Function(VFInValidStock<T> value)? inValidStock,
    TResult Function(VFShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (inValidStock != null) {
      return inValidStock(this);
    }
    return orElse();
  }
}

abstract class VFInValidStock<T> implements ValueFailure<T> {
  const factory VFInValidStock({required T failedValue}) = _$VFInValidStock<T>;

  @override
  T get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $VFInValidStockCopyWith<T, VFInValidStock<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VFShortPasswordCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $VFShortPasswordCopyWith(
          VFShortPassword<T> value, $Res Function(VFShortPassword<T>) then) =
      _$VFShortPasswordCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$VFShortPasswordCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $VFShortPasswordCopyWith<T, $Res> {
  _$VFShortPasswordCopyWithImpl(
      VFShortPassword<T> _value, $Res Function(VFShortPassword<T>) _then)
      : super(_value, (v) => _then(v as VFShortPassword<T>));

  @override
  VFShortPassword<T> get _value => super._value as VFShortPassword<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(VFShortPassword<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$VFShortPassword<T>
    with DiagnosticableTreeMixin
    implements VFShortPassword<T> {
  const _$VFShortPassword({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ValueFailure<$T>.shortPassword(failedValue: $failedValue)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ValueFailure<$T>.shortPassword'))
      ..add(DiagnosticsProperty('failedValue', failedValue));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VFShortPassword<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $VFShortPasswordCopyWith<T, VFShortPassword<T>> get copyWith =>
      _$VFShortPasswordCopyWithImpl<T, VFShortPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmailAdress,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidOTP,
    required TResult Function(T failedValue) invalidDescription,
    required TResult Function(T failedValue) invalidID,
    required TResult Function(T failedValue) inValidPrice,
    required TResult Function(T failedValue) inValidPercentage,
    required TResult Function(T failedValue) inValidQuantity,
    required TResult Function(T failedValue) inValidStock,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return shortPassword(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmailAdress,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidOTP,
    TResult Function(T failedValue)? invalidDescription,
    TResult Function(T failedValue)? invalidID,
    TResult Function(T failedValue)? inValidPrice,
    TResult Function(T failedValue)? inValidPercentage,
    TResult Function(T failedValue)? inValidQuantity,
    TResult Function(T failedValue)? inValidStock,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (shortPassword != null) {
      return shortPassword(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VFInvalidEmail<T> value) invalidEmailAdress,
    required TResult Function(VFInvalidName<T> value) invalidName,
    required TResult Function(VFInvalidPhone<T> value) invalidPhone,
    required TResult Function(VFInvalidOTP<T> value) invalidOTP,
    required TResult Function(VFInvalidDescription<T> value) invalidDescription,
    required TResult Function(VFInvalidID<T> value) invalidID,
    required TResult Function(VFInValidPrice<T> value) inValidPrice,
    required TResult Function(VFInValidPercentage<T> value) inValidPercentage,
    required TResult Function(VFInValidQuantity<T> value) inValidQuantity,
    required TResult Function(VFInValidStock<T> value) inValidStock,
    required TResult Function(VFShortPassword<T> value) shortPassword,
  }) {
    return shortPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VFInvalidEmail<T> value)? invalidEmailAdress,
    TResult Function(VFInvalidName<T> value)? invalidName,
    TResult Function(VFInvalidPhone<T> value)? invalidPhone,
    TResult Function(VFInvalidOTP<T> value)? invalidOTP,
    TResult Function(VFInvalidDescription<T> value)? invalidDescription,
    TResult Function(VFInvalidID<T> value)? invalidID,
    TResult Function(VFInValidPrice<T> value)? inValidPrice,
    TResult Function(VFInValidPercentage<T> value)? inValidPercentage,
    TResult Function(VFInValidQuantity<T> value)? inValidQuantity,
    TResult Function(VFInValidStock<T> value)? inValidStock,
    TResult Function(VFShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (shortPassword != null) {
      return shortPassword(this);
    }
    return orElse();
  }
}

abstract class VFShortPassword<T> implements ValueFailure<T> {
  const factory VFShortPassword({required T failedValue}) =
      _$VFShortPassword<T>;

  @override
  T get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $VFShortPasswordCopyWith<T, VFShortPassword<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
